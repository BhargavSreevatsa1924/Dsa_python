Trees - it is used to represent the data hierarchically as nodes connected by edges 






* Node: A fundamental unit of a tree that holds data; every element in a tree is a node.
* Root: The topmost node in a tree that has no parent; every tree has only one root.
* Edge: A link connecting two nodes, showing the relationship between parent and child.
* Parent & Child: A parent is a node with children, and a child is directly connected to its parent.
* Leaf (External Node): A node with no children; it marks the end of a branch.
* Subtree: A smaller tree formed from any node and all its descendants.


 
Structure of Node in Binary Tree
The structure of a node in a Binary Tree typically consists of several components:
1. Data/Value: This is the primary information or content stored in the node. It represents the actual data or value associated with the node, which can be of any data type depending on the application.
2. Left Child Reference: This reference or pointer points to the left child node of the current node. In a binary tree, a node can have at most one left child.
3. Right Child Reference: Similar to the left child reference, this pointer points to the right child node of the current node. In a binary tree, a node can have at most one right child.




Height of a Tree in data structure
The height of a tree is the length of the longest path from the root to any leaf node. It represents how deep the tree goes from top to bottom and is measured in the number of edges or levels.
* It helps determine if the tree is balanced or skewed.
* A balanced tree has a smaller height, typically around log(n).
* In balanced trees, operations are fast with O(log n) time.
* In unbalanced trees, operations slow down to O(n) time.
Depth of a Tree in data structure
The depth of a node in a tree refers to the length of the path from the root node to that specific node. It measures how many edges or levels are traversed to reach that node from the root.
* Depth shows a node’s level in the tree.
* Root has depth 0; each lower level increases depth by 1.
Time and Space Complexity of HEIGHT of a tree:
* Time Complexity: O(n) — Every node is visited exactly once.
* Space Complexity: O(h) — Due to the recursion stack, where h is the height of the tree (O(log n) for balanced, O(n) for skewed trees).
Binary Tree:
A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.
Binary Tree Traversal:
Binary trees can be traversed in different ways to access their nodes. The three most common traversal methods are:
1. In-Order Traversal: In this traversal, nodes are visited in the order left, root, right. It is commonly used for binary search trees and provides nodes in ascending order when applied to a BST.
2. Pre-Order Traversal: In pre-order traversal, nodes are visited in the order root, left, right. It is often used for creating a copy of the tree or for certain types of expression evaluation.
3. Post-Order Traversal: Post-order traversal visits nodes in the order left, right, root. It is used for tasks like deleting nodes from a tree.
Binary Search Tree (BST):
A binary search tree is a binary tree in which the left child of a node contains values less than or equal to the node’s value, and the right child contains values greater than the node’s value.
In a BST, the values in the tree are organized such that for any given node:
* All values in its left subtree are less than or equal to the node’s value.
* All values in its right subtree are greater than the node’s value.
* This ordering property ensures that elements in the tree are sorted in a way that makes searching and other operations efficient.
AVL Tree:
An AVL tree (Adelson-Velsky and Landis tree) is a self-balancing binary search tree where the height of the left and right subtrees of any node differs by at most one.
Two most important points in AVL Tree:
* Balancing Factor: Each node in an AVL tree stores a balance factor, which is the difference between the height of its left and right subtrees. If the balance factor of any node exceeds +1 or -1, the tree is considered unbalanced.
* Balancing Operations: When an insertion or deletion operation potentially disturbs the balance of the tree, AVL trees perform rotation operations to restore balance. There are four types of rotations:
⬅️Left Rotation (LL Rotation)
➡️Right Rotation (RR Rotation)
⬅️➡️Left-Right Rotation (LR Rotation)
➡️⬅️Right-Left Rotation (RL Rotation)
       These rotations maintain the AVL tree’s balance property.
Red-Black Tree:
A red-black tree is a self-balancing binary search tree with additional properties where each node is colored either red or black, and specific rules ensure the tree’s balance.
Two foremost important points about Red-Black Tree :
   * Balancing Criteria: Red-black trees maintain balance using color-coded nodes (either red or black) and the following criteria:
   * Every node is colored either red or black.
   * The root node is always black.
   * Red nodes cannot have red children; in other words, no two adjacent (parent and child) red nodes are allowed.
   * Every path from the root to a null (leaf) node must have the same number of black nodes. This property ensures that the tree remains balanced.
   * Balancing Operations: Red-black trees employ a set of rotations and color flips to restore balance after insertions and deletions. These operations ensure that the tree remains approximately balanced and that the longest path from the root to any leaf node (the height) is at most approximately twice as long as the shortest path.


B-Tree:
A B-tree is a self-balancing tree structure that can have a variable number of child nodes per node, making it suitable for organizing large amounts of data on disk or in databases.
B-trees are widely used in various applications, including:
   * File systems: B-trees are used to organize directory structures and file metadata efficiently.
   * Databases: B-trees are used for indexing data to enable fast retrieval and modification.
   * File organization: B-trees can be used for efficient indexing in databases, allowing for rapid searching based on key values.
   * External memory algorithms: B-trees are valuable in scenarios where data doesn’t entirely fit in memory and must be read from and written to disk.